diff --git a/extra/Configs/Config.in b/extra/Configs/Config.in
index 2fa0b07..84722ed 100644
--- a/extra/Configs/Config.in
+++ b/extra/Configs/Config.in
@@ -23,6 +23,7 @@ choice
 	default TARGET_i386 if DESIRED_TARGET_ARCH = "i386"
 	default TARGET_i960 if DESIRED_TARGET_ARCH = "i960"
 	default TARGET_ia64 if DESIRED_TARGET_ARCH = "ia64"
+	default TARGET_lm32 if DESIRED_TARGET_ARCH = "lm32"
 	default TARGET_m68k if DESIRED_TARGET_ARCH = "m68k"
 	default TARGET_microblaze if DESIRED_TARGET_ARCH = "microblaze"
 	default TARGET_mips if DESIRED_TARGET_ARCH = "mips"
@@ -75,6 +76,9 @@ config TARGET_i960
 config TARGET_ia64
 	bool "ia64"
 
+config TARGET_lm32
+	bool "lm32"
+
 config TARGET_m68k
 	bool "m68k"
 
@@ -170,6 +174,10 @@ if TARGET_ia64
 source "extra/Configs/Config.ia64"
 endif
 
+if TARGET_lm32
+source "extra/Configs/Config.lm32"
+endif
+
 if TARGET_m68k
 source "extra/Configs/Config.m68k"
 endif
diff --git a/extra/Configs/Config.lm32 b/extra/Configs/Config.lm32
new file mode 100644
index 0000000..a86692c
--- /dev/null
+++ b/extra/Configs/Config.lm32
@@ -0,0 +1,16 @@
+#
+# For a description of the syntax of this configuration file,
+# see extra/config/Kconfig-language.txt
+#
+
+config TARGET_ARCH
+	string
+	default "lm32"
+
+config FORCE_OPTIONS_FOR_ARCH
+	bool
+	default y
+	select ARCH_BIG_ENDIAN
+	select ARCH_HAS_NO_MMU
+	select ARCH_HAS_NO_LDSO
+	select HAVE_NO_PIC
diff --git a/extra/Configs/defconfigs/lm32 b/extra/Configs/defconfigs/lm32
new file mode 100644
index 0000000..f824ad8
--- /dev/null
+++ b/extra/Configs/defconfigs/lm32
@@ -0,0 +1,3 @@
+TARGET_lm32=y
+UCLIBC_CTOR_DTOR=n
+UCLIBC_HAS_FPU=n
diff --git a/libc/sysdeps/linux/common/dup3.c b/libc/sysdeps/linux/common/dup3.c
new file mode 100644
index 0000000..72a64c3
--- /dev/null
+++ b/libc/sysdeps/linux/common/dup3.c
@@ -0,0 +1,15 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * dup2() for uClibc
+ *
+ * Copyright (C) 2000-2006 Erik Andersen <andersen@uclibc.org>
+ *
+ * Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+ */
+
+#include <sys/syscall.h>
+#include <unistd.h>
+
+#if __NR_dup3
+_syscall3(int, dup3, int, oldfd, int, newfd, int, flags)
+#endif
diff --git a/libc/sysdeps/linux/lm32/Makefile b/libc/sysdeps/linux/lm32/Makefile
new file mode 100644
index 0000000..633c91f
--- /dev/null
+++ b/libc/sysdeps/linux/lm32/Makefile
@@ -0,0 +1,13 @@
+# Makefile for uClibc
+#
+# Copyright (C) 2000-2005 Erik Andersen <andersen@uclibc.org>
+#
+# Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+#
+
+top_srcdir=../../../../
+top_builddir=../../../../
+all: objs
+include $(top_builddir)Rules.mak
+include Makefile.arch
+include $(top_srcdir)Makerules
diff --git a/libc/sysdeps/linux/lm32/Makefile.arch b/libc/sysdeps/linux/lm32/Makefile.arch
new file mode 100644
index 0000000..eed9e7b
--- /dev/null
+++ b/libc/sysdeps/linux/lm32/Makefile.arch
@@ -0,0 +1,9 @@
+# Makefile for uClibc
+#
+# Copyright (C) 2000-2005 Erik Andersen <andersen@uclibc.org>
+#
+# Licensed under the LGPL v2.1, see the file COPYING.LIB in this tarball.
+#
+
+CSRC := 
+SSRC := clone.S setjmp.S __longjmp.S vfork.S
diff --git a/libc/sysdeps/linux/lm32/__longjmp.S b/libc/sysdeps/linux/lm32/__longjmp.S
new file mode 100644
index 0000000..cbb55f0
--- /dev/null
+++ b/libc/sysdeps/linux/lm32/__longjmp.S
@@ -0,0 +1,40 @@
+#define _SETJMP_H
+#define _ASM
+#include <bits/setjmp.h>
+
+#include <libc-symbols.h>
+
+.text
+.global C_SYMBOL_NAME(__longjmp)
+.type C_SYMBOL_NAME(__longjmp),@function
+.align 4
+
+C_SYMBOL_NAME(__longjmp):
+    /* load registers relative from r5 (arg0) */
+    lw      r11, (r1+0)
+    lw      r12, (r1+4)
+    lw      r13, (r1+8)
+    lw      r14, (r1+12)
+    lw      r15, (r1+16)
+    lw      r16, (r1+20)
+    lw      r17, (r1+24)
+    lw      r18, (r1+28)
+    lw      r19, (r1+32)
+    lw      r20, (r1+36)
+    lw      r21, (r1+40)
+    lw      r22, (r1+44)
+    lw      r23, (r1+48)
+    lw      r24, (r1+52)
+    lw      r25, (r1+56)
+    lw      gp, (r1+60)
+    lw      fp, (r1+64)
+    lw      sp, (r1+68)
+    lw      ra, (r1+72)
+
+    mv      r1, r2          /* copy val */
+    bne     r1, r0, 1f
+    mvi     r1, 1           /* val was zero, set it to 1 */
+1:
+    ret
+
+libc_hidden_def(__longjmp)
diff --git a/libc/sysdeps/linux/lm32/bits/endian.h b/libc/sysdeps/linux/lm32/bits/endian.h
new file mode 100644
index 0000000..1acee18
--- /dev/null
+++ b/libc/sysdeps/linux/lm32/bits/endian.h
@@ -0,0 +1,13 @@
+/* This file should define __BYTE_ORDER as appropriate for the machine
+   in question.  See string/endian.h for how to define it.
+
+   If only the stub bits/endian.h applies to a particular configuration,
+   bytesex.h is generated by running a program on the host machine.
+   So if cross-compiling to a machine with a different byte order,
+   the bits/endian.h file for that machine must exist.  */
+
+#ifndef _ENDIAN_H
+# error "Never use <bits/endian.h> directly; include <endian.h> instead."
+#endif
+
+#define __BYTE_ORDER __BIG_ENDIAN
diff --git a/libc/sysdeps/linux/lm32/bits/fcntl.h b/libc/sysdeps/linux/lm32/bits/fcntl.h
new file mode 100644
index 0000000..44e8f3f
--- /dev/null
+++ b/libc/sysdeps/linux/lm32/bits/fcntl.h
@@ -0,0 +1,240 @@
+/* O_*, F_*, FD_* bit values for Linux.
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_FCNTL_H
+# error "Never use <bits/fcntl.h> directly; include <fcntl.h> instead."
+#endif
+
+
+#include <sys/types.h>
+#ifdef __USE_GNU
+# include <bits/uio.h>
+#endif
+
+/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
+   located on an ext2 file system */
+#define O_ACCMODE	   0003
+#define O_RDONLY	     00
+#define O_WRONLY	     01
+#define O_RDWR		     02
+#define O_CREAT		   0100	/* not fcntl */
+#define O_EXCL		   0200	/* not fcntl */
+#define O_NOCTTY	   0400	/* not fcntl */
+#define O_TRUNC		  01000	/* not fcntl */
+#define O_APPEND	  02000
+#define O_NONBLOCK	  04000
+#define O_NDELAY	O_NONBLOCK
+#define O_SYNC		 010000
+#define O_FSYNC		 O_SYNC
+#define O_ASYNC		 020000
+
+#ifdef __USE_GNU
+# define O_DIRECTORY	 0200000	/* Must be a directory.	 */
+# define O_NOFOLLOW	0400000	/* Do not follow links.	 */
+# define O_DIRECT	040000	/* Direct disk access.	*/
+# define O_NOATIME     01000000 /* Do not set atime.  */
+# define O_CLOEXEC     02000000 /* set close_on_exec */
+#endif
+
+/* For now Linux has synchronisity options for data and read operations.
+   We define the symbols here but let them do the same as O_SYNC since
+   this is a superset.	*/
+#if defined __USE_POSIX199309 || defined __USE_UNIX98
+# define O_DSYNC	O_SYNC	/* Synchronize data.  */
+# define O_RSYNC	O_SYNC	/* Synchronize read operations.	 */
+#endif
+
+#ifdef __USE_LARGEFILE64
+# define O_LARGEFILE	0100000
+#endif
+
+/* Values for the second argument to `fcntl'.  */
+#define F_DUPFD		0	/* Duplicate file descriptor.  */
+#define F_GETFD		1	/* Get file descriptor flags.  */
+#define F_SETFD		2	/* Set file descriptor flags.  */
+#define F_GETFL		3	/* Get file status flags.  */
+#define F_SETFL		4	/* Set file status flags.  */
+#ifndef __USE_FILE_OFFSET64
+# define F_GETLK	5	/* Get record locking info.  */
+# define F_SETLK	6	/* Set record locking info (non-blocking).  */
+# define F_SETLKW	7	/* Set record locking info (blocking).	*/
+#else
+# define F_GETLK	F_GETLK64  /* Get record locking info.	*/
+# define F_SETLK	F_SETLK64  /* Set record locking info (non-blocking).*/
+# define F_SETLKW	F_SETLKW64 /* Set record locking info (blocking).  */
+#endif
+#define F_GETLK64	12	/* Get record locking info.  */
+#define F_SETLK64	13	/* Set record locking info (non-blocking).  */
+#define F_SETLKW64	14	/* Set record locking info (blocking).	*/
+
+#if defined __USE_BSD || defined __USE_XOPEN2K
+# define F_SETOWN	8	/* Get owner of socket (receiver of SIGIO).  */
+# define F_GETOWN	9	/* Set owner of socket (receiver of SIGIO).  */
+#endif
+
+#ifdef __USE_GNU
+# define F_SETSIG	10	/* Set number of signal to be sent.  */
+# define F_GETSIG	11	/* Get number of signal to be sent.  */
+#endif
+
+#ifdef __USE_GNU
+# define F_SETLEASE	1024	/* Set a lease.	 */
+# define F_GETLEASE	1025	/* Enquire what lease is active.  */
+# define F_NOTIFY	1026	/* Request notfications on a directory.	 */
+# define F_DUPFD_CLOEXEC 1030	/* Duplicate file descriptor with
+				   close-on-exit set on new fd.  */
+# define F_SETPIPE_SZ	1031	/* Set of pipe page size array */
+# define F_GETPIPE_SZ	1032	/* Get of pipe page size array */
+#endif
+
+/* For F_[GET|SET]FL.  */
+#define FD_CLOEXEC	1	/* actually anything with low bit set goes */
+
+/* For posix fcntl() and `l_type' field of a `struct flock' for lockf().  */
+#define F_RDLCK		0	/* Read lock.  */
+#define F_WRLCK		1	/* Write lock.	*/
+#define F_UNLCK		2	/* Remove lock.	 */
+
+/* For old implementation of bsd flock().  */
+#define F_EXLCK		4	/* or 3 */
+#define F_SHLCK		8	/* or 4 */
+
+#ifdef __USE_BSD
+/* Operations for bsd flock(), also used by the kernel implementation.	*/
+# define LOCK_SH	1	/* shared lock */
+# define LOCK_EX	2	/* exclusive lock */
+# define LOCK_NB	4	/* or'd with one of the above to prevent
+				   blocking */
+# define LOCK_UN	8	/* remove lock */
+#endif
+
+#ifdef __USE_GNU
+# define LOCK_MAND	32	/* This is a mandatory flock:	*/
+# define LOCK_READ	64	/* ... which allows concurrent read operations.	 */
+# define LOCK_WRITE	128	/* ... which allows concurrent write operations.  */
+# define LOCK_RW	192	/* ... Which allows concurrent read & write operations.	 */
+#endif
+
+#ifdef __USE_GNU
+/* Types of directory notifications that may be requested with F_NOTIFY.  */
+# define DN_ACCESS	0x00000001	/* File accessed.  */
+# define DN_MODIFY	0x00000002	/* File modified.  */
+# define DN_CREATE	0x00000004	/* File created.  */
+# define DN_DELETE	0x00000008	/* File removed.  */
+# define DN_RENAME	0x00000010	/* File renamed.  */
+# define DN_ATTRIB	0x00000020	/* File changed attibutes.  */
+# define DN_MULTISHOT	0x80000000	/* Don't remove notifier.  */
+#endif
+
+struct flock
+  {
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+#ifndef __USE_FILE_OFFSET64
+    __off_t l_start;	/* Offset where the lock begins.  */
+    __off_t l_len;	/* Size of the locked area; zero means until EOF.  */
+#else
+    __off64_t l_start;	/* Offset where the lock begins.  */
+    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
+#endif
+    __pid_t l_pid;	/* Process holding the lock.  */
+  };
+
+#ifdef __USE_LARGEFILE64
+struct flock64
+  {
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+    __off64_t l_start;	/* Offset where the lock begins.  */
+    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
+    __pid_t l_pid;	/* Process holding the lock.  */
+  };
+#endif
+
+/* Define some more compatibility macros to be backward compatible with
+   BSD systems which did not managed to hide these kernel macros.  */
+#ifdef	__USE_BSD
+# define FAPPEND	O_APPEND
+# define FFSYNC		O_FSYNC
+# define FASYNC		O_ASYNC
+# define FNONBLOCK	O_NONBLOCK
+# define FNDELAY	O_NDELAY
+#endif /* Use BSD.  */
+
+/* Advise to `posix_fadvise'.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_FADV_NORMAL	0 /* No further special treatment.  */
+# define POSIX_FADV_RANDOM	1 /* Expect random page references.  */
+# define POSIX_FADV_SEQUENTIAL	2 /* Expect sequential page references.	 */
+# define POSIX_FADV_WILLNEED	3 /* Will need these pages.  */
+# define POSIX_FADV_DONTNEED	4 /* Don't need these pages.  */
+# define POSIX_FADV_NOREUSE	5 /* Data will be accessed once.  */
+#endif
+
+
+#if defined __USE_GNU && defined __UCLIBC_LINUX_SPECIFIC__
+/* Flags for SYNC_FILE_RANGE.  */
+# define SYNC_FILE_RANGE_WAIT_BEFORE	1 /* Wait upon writeout of all pages
+					     in the range before performing the
+					     write.  */
+# define SYNC_FILE_RANGE_WRITE		2 /* Initiate writeout of all those
+					     dirty pages in the range which are
+					     not presently under writeback.  */
+# define SYNC_FILE_RANGE_WAIT_AFTER	4 /* Wait upon writeout of all pages in
+					     the range after performing the
+					     write.  */
+
+/* Flags for SPLICE and VMSPLICE.  */
+# define SPLICE_F_MOVE		1	/* Move pages instead of copying.  */
+# define SPLICE_F_NONBLOCK	2	/* Don't block on the pipe splicing
+					   (but we may still block on the fd
+					   we splice from/to).  */
+# define SPLICE_F_MORE		4	/* Expect more data.  */
+# define SPLICE_F_GIFT		8	/* Pages passed in are a gift.  */
+#endif
+
+__BEGIN_DECLS
+
+#if defined __USE_GNU && defined __UCLIBC_LINUX_SPECIFIC__
+
+/* Provide kernel hint to read ahead.  */
+extern ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
+    __THROW;
+
+
+/* Selective file content synch'ing.  */
+extern int sync_file_range (int __fd, __off64_t __from, __off64_t __to,
+			    unsigned int __flags);
+
+/* Splice address range into a pipe.  */
+extern ssize_t vmsplice (int __fdout, const struct iovec *__iov,
+			 size_t __count, unsigned int __flags);
+
+/* Splice two files together.  */
+extern ssize_t splice (int __fdin, __off64_t *__offin, int __fdout,
+		       __off64_t *__offout, size_t __len,
+		       unsigned int __flags);
+
+/* In-kernel implementation of tee for pipe buffers.  */
+extern ssize_t tee (int __fdin, int __fdout, size_t __len,
+		    unsigned int __flags);
+
+#endif
+__END_DECLS
+
diff --git a/libc/sysdeps/linux/lm32/bits/kernel_stat.h b/libc/sysdeps/linux/lm32/bits/kernel_stat.h
new file mode 100644
index 0000000..c998b56
--- /dev/null
+++ b/libc/sysdeps/linux/lm32/bits/kernel_stat.h
@@ -0,0 +1,50 @@
+#ifndef _BITS_STAT_STRUCT_H
+#define _BITS_STAT_STRUCT_H
+
+#ifndef _LIBC
+#error bits/kernel_stat.h is for internal uClibc use only!
+#endif
+
+struct kernel_stat
+{
+        unsigned long   st_dev;         /* Device.  */
+        unsigned long   st_ino;         /* File serial number.  */
+        unsigned int    st_mode;        /* File mode.  */
+        unsigned int    st_nlink;       /* Link count.  */
+        unsigned int    st_uid;         /* User ID of the file's owner.  */
+        unsigned int    st_gid;         /* Group ID of the file's group. */
+        unsigned long   st_rdev;        /* Device number, if device.  */
+        unsigned long   __pad1;
+        long            st_size;        /* Size of file, in bytes.  */
+        int             st_blksize;     /* Optimal block size for I/O.  */
+        int             __pad2;
+        long            st_blocks;      /* Number 512-byte blocks allocated. */
+        struct timespec st_atim;        /* Time of last access. */
+        struct timespec st_mtim;        /* Time of last modification. */
+        struct timespec st_ctim;        /* Time of last status change. */
+        unsigned int    __unused4;
+        unsigned int    __unused5;
+};
+
+struct kernel_stat64
+{
+        unsigned long long st_dev;      /* Device.  */
+        unsigned long long st_ino;      /* File serial number.  */
+        unsigned int    st_mode;        /* File mode.  */
+        unsigned int    st_nlink;       /* Link count.  */
+        unsigned int    st_uid;         /* User ID of the file's owner.  */
+        unsigned int    st_gid;         /* Group ID of the file's group. */
+        unsigned long long st_rdev;     /* Device number, if device.  */
+        unsigned long long __pad1;
+        long long       st_size;        /* Size of file, in bytes.  */
+        int             st_blksize;     /* Optimal block size for I/O.  */
+        int             __pad2;
+        long long       st_blocks;      /* Number 512-byte blocks allocated. */
+        struct timespec st_atim;        /* Time of last access. */
+        struct timespec st_mtim;        /* Time of last modification. */
+        struct timespec st_ctim;        /* Time of last status change. */
+        unsigned int    __unused4;
+        unsigned int    __unused5;
+};
+
+#endif  /*  _BITS_STAT_STRUCT_H */
diff --git a/libc/sysdeps/linux/lm32/bits/kernel_types.h b/libc/sysdeps/linux/lm32/bits/kernel_types.h
new file mode 100644
index 0000000..2c3c6df
--- /dev/null
+++ b/libc/sysdeps/linux/lm32/bits/kernel_types.h
@@ -0,0 +1,37 @@
+#ifndef __ASM_GENERIC_POSIX_TYPES_H
+#define __ASM_GENERIC_POSIX_TYPES_H
+
+typedef unsigned long   __kernel_ino_t;
+typedef unsigned int    __kernel_mode_t;
+typedef unsigned long   __kernel_nlink_t;
+typedef long            __kernel_off_t;
+typedef int             __kernel_pid_t;
+typedef int             __kernel_ipc_pid_t;
+typedef unsigned int    __kernel_uid_t;
+typedef unsigned int    __kernel_gid_t;
+typedef unsigned int    __kernel_size_t;
+typedef int             __kernel_ssize_t;
+typedef int             __kernel_ptrdiff_t;
+typedef long            __kernel_time_t;
+typedef long            __kernel_suseconds_t;
+typedef long            __kernel_clock_t;
+typedef int             __kernel_timer_t;
+typedef int             __kernel_clockid_t;
+typedef int             __kernel_daddr_t;
+typedef char *          __kernel_caddr_t;
+typedef unsigned short  __kernel_uid16_t;
+typedef unsigned short  __kernel_gid16_t;
+typedef __kernel_uid_t  __kernel_uid32_t;
+typedef __kernel_gid_t  __kernel_gid32_t;
+
+typedef __kernel_uid_t  __kernel_old_uid_t;
+typedef __kernel_gid_t  __kernel_old_gid_t;
+typedef unsigned int    __kernel_old_dev_t;
+
+typedef long long       __kernel_loff_t;
+
+typedef struct {
+        int val[2];
+} __kernel_fsid_t;
+
+#endif /* __ASM_GENERIC_POSIX_TYPES_H */
diff --git a/libc/sysdeps/linux/lm32/bits/setjmp.h b/libc/sysdeps/linux/lm32/bits/setjmp.h
new file mode 100644
index 0000000..6798083
--- /dev/null
+++ b/libc/sysdeps/linux/lm32/bits/setjmp.h
@@ -0,0 +1,24 @@
+#ifndef _BITS_SETJMP_H
+#define _BITS_SETJMP_H	1
+
+#if !defined _SETJMP_H && !defined _PTHREAD_H
+# error "Never include <bits/setjmp.h> directly; use <setjmp.h> instead."
+#endif
+
+#ifndef _ASM
+typedef struct
+  {
+    int __regs[15]; /* callee-saved registers r11-r25 */
+    void *__gp;     /* global pointer */
+    void *__fp;     /* frame pointer */
+    void *__sp;     /* stack pointer */
+    void *__ra;     /* return address */
+  } __jmp_buf[1];
+#endif
+
+/* Test if longjmp to JMPBUF would unwind the frame
+   containing a local variable at ADDRESS.  */
+#define _JMPBUF_UNWINDS(jmpbuf, address) \
+  ((void *) (address) < (void *) (jmpbuf)[0].__sp)
+
+#endif
diff --git a/libc/sysdeps/linux/lm32/bits/stackinfo.h b/libc/sysdeps/linux/lm32/bits/stackinfo.h
new file mode 100644
index 0000000..695616e
--- /dev/null
+++ b/libc/sysdeps/linux/lm32/bits/stackinfo.h
@@ -0,0 +1,28 @@
+/* Copyright (C) 1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* This file contains a bit of information about the stack allocation
+   of the processor.  Since there is no general truth we can't say
+   anything here.  */
+
+#ifndef _STACKINFO_H
+#define _STACKINFO_H	1
+
+#define _STACK_GROWS_DOWN	1
+
+#endif	/* stackinfo.h */
diff --git a/libc/sysdeps/linux/lm32/bits/syscalls.h b/libc/sysdeps/linux/lm32/bits/syscalls.h
new file mode 100644
index 0000000..826399a
--- /dev/null
+++ b/libc/sysdeps/linux/lm32/bits/syscalls.h
@@ -0,0 +1,54 @@
+#ifndef _BITS_SYSCALLS_H
+#define _BITS_SYSCALLS_H
+#ifndef _SYSCALL_H
+# error "Never use <bits/syscalls.h> directly; include <sys/syscall.h> instead."
+#endif
+
+
+#ifndef __ASSEMBLER__
+
+#define INTERNAL_SYSCALL_NCS(name, err, nr, args...)                    \
+        ({                                                              \
+                register int __ret __asm__("r1");                       \
+                register int _scno __asm__("r8") = name;                \
+                LOAD_ARGS_##nr (args);                                  \
+                __asm__ __volatile__("scall"                            \
+                              : "=r" (__ret)                            \
+                              :  "r"(_scno) ASM_ARGS_##nr               \
+                              : __SYSCALL_CLOBBERS );                   \
+                __ret;                                                  \
+        })
+
+/* original port had ret >= -125 ?! */
+
+#define LOAD_ARGS_0() do { } while(0)
+#define ASM_ARGS_0
+#define LOAD_ARGS_1(a1)                                 \
+        register int _a1 __asm__("r1") = (int)(a1);     \
+        LOAD_ARGS_0()
+#define ASM_ARGS_1      ASM_ARGS_0, "r"(_a1)
+#define LOAD_ARGS_2(a1, a2)                             \
+        register int _a2 __asm__("r2") = (int)(a2);     \
+        LOAD_ARGS_1(a1)
+#define ASM_ARGS_2      ASM_ARGS_1, "r"(_a2)
+#define LOAD_ARGS_3(a1, a2, a3)                         \
+        register int _a3 __asm__("r3") = (int)(a3);     \
+        LOAD_ARGS_2(a1, a2)
+#define ASM_ARGS_3      ASM_ARGS_2, "r"(_a3)
+#define LOAD_ARGS_4(a1, a2, a3, a4)                     \
+        register int _a4 __asm__("r4") = (int)(a4);     \
+        LOAD_ARGS_3(a1, a2, a3)
+#define ASM_ARGS_4      ASM_ARGS_3, "r"(_a4)
+#define LOAD_ARGS_5(a1, a2, a3, a4, a5)                 \
+        register int _a5 __asm__("r5") = (int)(a5);     \
+        LOAD_ARGS_4(a1, a2, a3, a4)
+#define ASM_ARGS_5      ASM_ARGS_4, "r"(_a5)
+#define LOAD_ARGS_6(a1, a2, a3, a4, a5, a6)             \
+        register int _a6 __asm__("r6") = (int)(a6);     \
+        LOAD_ARGS_5(a1, a2, a3, a4, a5)
+#define ASM_ARGS_6      ASM_ARGS_5, "r"(_a6)
+
+#define __SYSCALL_CLOBBERS
+
+#endif /* __ASSEMBLER__ */
+#endif /* _BITS_SYSCALLS_H */
diff --git a/libc/sysdeps/linux/lm32/bits/uClibc_arch_features.h b/libc/sysdeps/linux/lm32/bits/uClibc_arch_features.h
new file mode 100644
index 0000000..4bab547
--- /dev/null
+++ b/libc/sysdeps/linux/lm32/bits/uClibc_arch_features.h
@@ -0,0 +1,48 @@
+/*
+ * Track misc arch-specific features that aren't config options
+ */
+
+#ifndef _BITS_UCLIBC_ARCH_FEATURES_H
+#define _BITS_UCLIBC_ARCH_FEATURES_H
+
+/* instruction used when calling abort() to kill yourself */
+/*#define __UCLIBC_ABORT_INSTRUCTION__ "asm instruction"*/
+#undef __UCLIBC_ABORT_INSTRUCTION__
+
+/* can your target use syscall6() for mmap ? */
+#define __UCLIBC_MMAP_HAS_6_ARGS__
+
+/* does your target use syscall4() for truncate64 ? (32bit arches only) */
+#undef __UCLIBC_TRUNCATE64_HAS_4_ARGS__
+
+/* does your target have a broken create_module() ? */
+#undef __UCLIBC_BROKEN_CREATE_MODULE__
+
+/* does your target have to worry about older [gs]etrlimit() ? */
+#undef __UCLIBC_HANDLE_OLDER_RLIMIT__
+
+/* does your target have an asm .set ? */
+#define __UCLIBC_HAVE_ASM_SET_DIRECTIVE__
+
+/* define if target doesn't like .global */
+#undef __UCLIBC_ASM_GLOBAL_DIRECTIVE__
+
+/* define if target supports .weak */
+#define __UCLIBC_HAVE_ASM_WEAK_DIRECTIVE__
+
+/* define if target supports .weakext */
+#undef __UCLIBC_HAVE_ASM_WEAKEXT_DIRECTIVE__
+
+/* needed probably only for ppc64 */
+#undef __UCLIBC_HAVE_ASM_GLOBAL_DOT_NAME__
+
+/* define if target supports CFI pseudo ops */
+#undef __UCLIBC_HAVE_ASM_CFI_DIRECTIVES__
+
+/* define if target supports IEEE signed zero floats */
+#define __UCLIBC_HAVE_SIGNED_ZERO__
+
+/* only weird assemblers generally need this */
+#undef __UCLIBC_ASM_LINE_SEP__
+
+#endif /* _BITS_UCLIBC_ARCH_FEATURES_H */
diff --git a/libc/sysdeps/linux/lm32/bits/uClibc_page.h b/libc/sysdeps/linux/lm32/bits/uClibc_page.h
new file mode 100644
index 0000000..a2d7ea2
--- /dev/null
+++ b/libc/sysdeps/linux/lm32/bits/uClibc_page.h
@@ -0,0 +1,26 @@
+/*  Copyright (C) 2004     Erik Andersen
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2.1 of the License, or (at your option) any later version.
+ *
+ *  The GNU C Library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with the GNU C Library; if not, write to the Free
+ *  Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+ *  02111-1307 USA.
+ */
+
+#ifndef _UCLIBC_PAGE_H
+#define _UCLIBC_PAGE_H
+
+#define PAGE_SHIFT	12
+#define PAGE_SIZE	(1UL << PAGE_SHIFT)
+#define PAGE_MASK	(~(PAGE_SIZE-1))
+
+#endif /* _UCLIBC_PAGE_H */
diff --git a/libc/sysdeps/linux/lm32/bits/wordsize.h b/libc/sysdeps/linux/lm32/bits/wordsize.h
new file mode 100644
index 0000000..b47eee9
--- /dev/null
+++ b/libc/sysdeps/linux/lm32/bits/wordsize.h
@@ -0,0 +1 @@
+#define __WORDSIZE 32
diff --git a/libc/sysdeps/linux/lm32/clone.S b/libc/sysdeps/linux/lm32/clone.S
new file mode 100644
index 0000000..adc8b1a
--- /dev/null
+++ b/libc/sysdeps/linux/lm32/clone.S
@@ -0,0 +1,52 @@
+#include <features.h>
+#include <sys/syscall.h>
+#define _ERRNO_H    1
+#include <bits/errno.h>
+
+#ifdef __NR_clone
+
+.text
+.global clone
+.type clone,@function
+.align 4
+
+clone:
+	be	r1, r0, 2f
+	be	r2, r0, 2f
+
+	mvi	r8, __NR_clone
+	scall
+
+	mvi	r3, -4095
+	bgeu	r1, r3, 1f
+
+	be      r1, r0, __thread_start
+
+	ret
+
+__thread_start:
+	mvi	fp, 0
+	call	r2
+
+	calli HIDDEN_JUMPTARGET(_exit)
+
+    /* Stop the unstoppable.  */
+9:
+	bi      9b
+
+2:
+	mvi     r1, -EINVAL
+1:
+	addi	sp, sp, -8
+	sw	(sp+4), ra
+	sw	(sp+8), r1
+	calli   __errno_location
+ 	lw	r2, (sp+8)
+	lw	ra, (sp+4)
+	sub	r2, r0, r2
+	sw      (r1+0), r2
+	mvi     r1, -1
+	addi	sp, sp, 8
+	ret
+
+#endif /* __NR_clone */
diff --git a/libc/sysdeps/linux/lm32/crt1.S b/libc/sysdeps/linux/lm32/crt1.S
new file mode 100644
index 0000000..661a159
--- /dev/null
+++ b/libc/sysdeps/linux/lm32/crt1.S
@@ -0,0 +1,21 @@
+.text
+.globl _start
+.type _start,@function
+.type main,@function
+.type __uClibc_main,@function
+
+_start:
+    mvi     fp, 0              /* clear fp */
+    mvhi    r1, hi(main)       /* main */
+    ori     r1, r1, lo(main)
+    lw      r2, (sp+0)         /* argc */
+    addi    r3, sp, 4          /* argv */
+    mvhi    r4, hi(_init)      /* app_init */
+    ori     r4, r4, lo(_init)
+    mvhi    r5, hi(_fini)      /* app_fini */
+    ori     r5, r5, lo(_fini)
+    mvi     r6, 0              /* rtld_fini */
+	mv      r7, sp             /* stack_end */
+    
+    calli   __uClibc_main
+
diff --git a/libc/sysdeps/linux/lm32/crti.S b/libc/sysdeps/linux/lm32/crti.S
new file mode 100644
index 0000000..8ceb15b
--- /dev/null
+++ b/libc/sysdeps/linux/lm32/crti.S
@@ -0,0 +1,17 @@
+.section .init
+.global _init
+.type _init,@function
+.align 4
+
+_init:
+    addi    sp, sp, -4
+    sw      (sp+4), ra
+
+.section .fini
+.global _fini
+.type _fini,@function
+.align 4
+
+_fini:
+    addi    sp, sp, -4
+    sw      (sp+4), ra
diff --git a/libc/sysdeps/linux/lm32/crtn.S b/libc/sysdeps/linux/lm32/crtn.S
new file mode 100644
index 0000000..93643ac
--- /dev/null
+++ b/libc/sysdeps/linux/lm32/crtn.S
@@ -0,0 +1,11 @@
+.section .init
+
+    lw      ra, (sp+4)
+    addi    sp, sp, 4
+    ret
+
+.section .fini
+
+    lw      ra, (sp+4)
+    addi    sp, sp, 4
+    ret
diff --git a/libc/sysdeps/linux/lm32/setjmp.S b/libc/sysdeps/linux/lm32/setjmp.S
new file mode 100644
index 0000000..6badd80
--- /dev/null
+++ b/libc/sysdeps/linux/lm32/setjmp.S
@@ -0,0 +1,53 @@
+#define _SETJMP_H
+#define _ASM
+#include <bits/setjmp.h>
+
+#include <libc-symbols.h>
+
+.text
+.global C_SYMBOL_NAME(setjmp)
+.type C_SYMBOL_NAME(setjmp),@function
+.align 4
+
+C_SYMBOL_NAME(setjmp):
+    mvi     r2, 1       /* save the signal mask */
+    bi      C_SYMBOL_NAME(__sigsetjmp)
+
+.text
+.global C_SYMBOL_NAME(_setjmp)
+.type C_SYMBOL_NAME(_setjmp),@function
+.align 4
+
+C_SYMBOL_NAME(_setjmp):
+    mvi     r2, 0       /* don't save the signal mask */
+    bi      C_SYMBOL_NAME(__sigsetjmp)
+
+.text
+.global C_SYMBOL_NAME(__sigsetjmp)
+.type C_SYMBOL_NAME(__sigsetjmp),@function
+.align 4
+
+C_SYMBOL_NAME(__sigsetjmp):
+    /* save registers relative to r1 (arg0) */
+    sw      (r1+0), r11
+    sw      (r1+4), r12
+    sw      (r1+8), r13
+    sw      (r1+12), r14
+    sw      (r1+16), r15
+    sw      (r1+20), r16
+    sw      (r1+24), r17
+    sw      (r1+28), r18
+    sw      (r1+32), r19
+    sw      (r1+36), r20
+    sw      (r1+40), r21
+    sw      (r1+44), r22
+    sw      (r1+48), r23
+    sw      (r1+52), r24
+    sw      (r1+56), r25
+    sw      (r1+60), gp
+    sw      (r1+64), fp
+    sw      (r1+68), sp
+    sw      (r1+72), ra
+
+    /* make a tail call to __sigjmp_save; it takes the same args */
+    bi      C_SYMBOL_NAME(__sigjmp_save)
diff --git a/libc/sysdeps/linux/lm32/sys/procfs.h b/libc/sysdeps/linux/lm32/sys/procfs.h
new file mode 100644
index 0000000..c545fe7
--- /dev/null
+++ b/libc/sysdeps/linux/lm32/sys/procfs.h
@@ -0,0 +1,128 @@
+/* Copyright (C) 1996, 1997, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_PROCFS_H
+#define _SYS_PROCFS_H	1
+
+/* This is somewhat modelled after the file of the same name on SVR4
+   systems.  It provides a definition of the core file format for ELF
+   used on Linux.  It doesn't have anything to do with the /proc file
+   system, even though Linux has one.
+
+   Anyway, the whole purpose of this file is for GDB and GDB only.
+   Don't read too much into it.  Don't use it for anything other than
+   GDB unless you know what you are doing.  */
+
+#include <features.h>
+#include <sys/time.h>
+#include <sys/types.h>
+
+
+/* Type for a general-purpose register.  */
+#ifndef ELF_GREG_T
+#define ELF_GREG_T
+typedef unsigned long elf_greg_t;
+#endif
+
+#define ELF_NGREG 32
+
+#ifndef ELF_GREGSET_T
+#define ELF_GREGSET_T
+typedef elf_greg_t elf_gregset_t[ELF_NGREG];
+#endif
+
+/* Register set for the floating-point registers.  */
+#ifndef ELF_FPREGSET_T
+#define ELF_FPREGSET_T
+typedef elf_greg_t elf_fpregset_t;
+#endif
+
+struct elf_siginfo
+{
+	int	si_signo;			/* signal number */
+	int	si_code;			/* extra code */
+	int	si_errno;			/* errno */
+};
+
+
+/*
+ * Definitions to generate Intel SVR4-like core files.
+ * These mostly have the same names as the SVR4 types with "elf_"
+ * tacked on the front to prevent clashes with linux definitions,
+ * and the typedef forms have been avoided.  This is mostly like
+ * the SVR4 structure, but more Linuxy, with things that Linux does
+ * not support and which gdb doesn't really use excluded.
+ * Fields present but not used are marked with "XXX".
+ */
+struct elf_prstatus
+{
+	struct elf_siginfo pr_info;	/* Info associated with signal */
+	short	pr_cursig;		/* Current signal */
+	unsigned long pr_sigpend;	/* Set of pending signals */
+	unsigned long pr_sighold;	/* Set of held signals */
+	__kernel_pid_t	pr_pid;
+	__kernel_pid_t	pr_ppid;
+	__kernel_pid_t	pr_pgrp;
+	__kernel_pid_t	pr_sid;
+	struct timeval pr_utime;	/* User time */
+	struct timeval pr_stime;	/* System time */
+	struct timeval pr_cutime;	/* Cumulative user time */
+	struct timeval pr_cstime;	/* Cumulative system time */
+	elf_gregset_t pr_reg;	/* GP registers */
+	int pr_fpvalid;		/* True if math co-processor being used.  */
+};
+
+#define ELF_PRARGSZ	(80)	/* Number of chars for args */
+
+struct elf_prpsinfo
+{
+	char	pr_state;	/* numeric process state */
+	char	pr_sname;	/* char for pr_state */
+	char	pr_zomb;	/* zombie */
+	char	pr_nice;	/* nice val */
+	unsigned long pr_flag;	/* flags */
+	__kernel_uid_t	pr_uid;
+	__kernel_gid_t	pr_gid;
+	__kernel_pid_t	pr_pid, pr_ppid, pr_pgrp, pr_sid;
+	/* Lots missing */
+	char	pr_fname[16];	/* filename of executable */
+	char	pr_psargs[ELF_PRARGSZ];	/* initial part of arg list */
+};
+
+
+/* The rest of this file provides the types for emulation of the
+   Solaris <proc_service.h> interfaces that should be implemented by
+   users of libthread_db.  */
+
+/* Addresses.  */
+typedef void *psaddr_t;
+
+/* Register sets.  Linux has different names.  */
+typedef elf_gregset_t prgregset_t;
+typedef elf_fpregset_t prfpregset_t;
+
+/* We don't have any differences between processes and threads,
+   therefore have only one PID type.  */
+typedef __kernel_pid_t lwpid_t;
+
+/* Process status and info.  In the end we do provide typedefs for them.  */
+typedef struct elf_prstatus prstatus_t;
+typedef struct elf_prpsinfo prpsinfo_t;
+
+
+#endif	/* sys/procfs.h */
diff --git a/libc/sysdeps/linux/lm32/sys/ucontext.h b/libc/sysdeps/linux/lm32/sys/ucontext.h
new file mode 100644
index 0000000..366158f
--- /dev/null
+++ b/libc/sysdeps/linux/lm32/sys/ucontext.h
@@ -0,0 +1,41 @@
+/* Copyright (C) 1997, 1998, 1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_UCONTEXT_H
+#define _SYS_UCONTEXT_H	1
+
+#include <features.h>
+#include <signal.h>
+
+/* We need the signal context definitions even if they are not used
+   included in <signal.h>.  */
+#include <bits/sigcontext.h>
+
+typedef struct sigcontext mcontext_t;
+
+/* Userlevel context.  */
+typedef struct ucontext
+  {
+    unsigned long uc_flags;
+    struct ucontext *uc_link;
+    stack_t uc_stack;
+    mcontext_t uc_mcontext;
+    __sigset_t uc_sigmask;
+  } ucontext_t;
+
+#endif /* sys/ucontext.h */
diff --git a/libc/sysdeps/linux/lm32/sys/user.h b/libc/sysdeps/linux/lm32/sys/user.h
new file mode 100644
index 0000000..e8a8aaa
--- /dev/null
+++ b/libc/sysdeps/linux/lm32/sys/user.h
@@ -0,0 +1,40 @@
+/* Copyright (C) 1998 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_USER_H
+
+#define _SYS_USER_H	1
+#include <features.h>
+
+#include <asm/ptrace.h>
+
+struct user {
+	struct pt_regs	regs;			/* entire machine state */
+	size_t		u_tsize;		/* text size (pages) */
+	size_t		u_dsize;		/* data size (pages) */
+	size_t		u_ssize;		/* stack size (pages) */
+	unsigned long	start_code;		/* text starting address */
+	unsigned long	start_data;		/* data starting address */
+	unsigned long	start_stack;		/* stack starting address */
+	long int	signal;			/* signal causing core dump */
+	struct regs *	u_ar0;			/* help gdb find registers */
+	unsigned long	magic;			/* identifies a core file */
+	char		u_comm[32];		/* user command name */
+};
+
+#endif  /* sys/user.h */
diff --git a/libc/sysdeps/linux/lm32/vfork.S b/libc/sysdeps/linux/lm32/vfork.S
new file mode 100644
index 0000000..f651ba6
--- /dev/null
+++ b/libc/sysdeps/linux/lm32/vfork.S
@@ -0,0 +1,42 @@
+#include <features.h>
+
+#define _ERRNO_H
+#include <bits/errno.h>
+#include <asm/unistd.h>
+#define _SIGNAL_H
+#include <bits/signum.h>
+
+#define CLONE_VM        0x00000100     /* set if VM shared between processes */
+#define CLONE_VFORK     0x00004000     /* set if the parent wants the child to */
+
+.text
+.global	__vfork
+.hidden	__vfork
+.type	__vfork,%function
+.align 4
+
+__vfork:
+	mvi	r2, 0
+	mvi	r3, CLONE_VFORK | CLONE_VM | SIGCHLD
+	mvi	r8, __NR_clone
+	scall
+
+	mvi	r2, -4096
+	bgeu	r2, r1, 1f
+
+	addi	sp, sp, -8
+	sw	(sp+4), ra
+	sw	(sp+8), r1
+	calli	__errno_location
+	lw	r2, (sp+8)
+	lw	ra, (sp+4)
+	sub	r2, r0, r2
+	sw	(r1+0), r2
+	addi	sp, sp, 8
+	mvi	r1, -1
+1:
+	ret
+
+.size __vfork,.-__vfork
+weak_alias(__vfork,vfork)
+libc_hidden_weak(vfork)
diff --git a/test/Rules.mak b/test/Rules.mak
index 2131a7b..246dc76 100644
--- a/test/Rules.mak
+++ b/test/Rules.mak
@@ -39,6 +39,7 @@ TARGET_ARCH:=$(shell $(CC) -dumpmachine | sed -e s'/-.*//' \
 	-e 's/mips.*/mips/' \
 	-e 's/cris.*/cris/' \
 	-e 's/xtensa.*/xtensa/' \
+	-e 's/lm32.*/lm32/' \
 	)
 endif
 export TARGET_ARCH
